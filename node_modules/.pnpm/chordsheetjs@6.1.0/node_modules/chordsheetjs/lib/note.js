"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _constants = require("./constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }

var A = 'A'.charCodeAt(0);
var G = 'G'.charCodeAt(0);
var TRANSPOSE_DISTANCE_MAJOR = [null, 0, 2, 4, 5, 7, 9, 11];
var TRANSPOSE_DISTANCE_MINOR = [null, 0, 2, 3, 5, 7, 8, 11];

function keyToCharCode(key) {
  return key.toUpperCase().charCodeAt(0);
}

function clamp(note, min, max) {
  var newNote = note;

  if (newNote < min) {
    newNote += 7;
  } else if (newNote > max) {
    newNote -= 7;
  }

  return newNote;
}

function numeralToNumber(numeral) {
  for (var i = 0, count = _constants.ROMAN_NUMERALS.length; i < count; i += 1) {
    var romanNumeral = _constants.ROMAN_NUMERALS[i];

    if (romanNumeral === numeral || romanNumeral.toLowerCase() === numeral) {
      return i + 1;
    }
  }

  return null;
}

function numberToNumeral(number) {
  return _constants.ROMAN_NUMERALS[number - 1];
}

var _set = /*#__PURE__*/new WeakSet();

var Note = /*#__PURE__*/function () {
  function Note(_ref) {
    var note = _ref.note,
        type = _ref.type,
        _ref$minor = _ref.minor,
        minor = _ref$minor === void 0 ? false : _ref$minor;

    _classCallCheck(this, Note);

    _classPrivateMethodInitSpec(this, _set);

    this._note = note;
    this.type = type;
    this.minor = minor;
  }

  _createClass(Note, [{
    key: "toNumeral",
    value: function toNumeral() {
      if (this.isNumeral()) {
        return this.clone();
      }

      if (this.isNumeric()) {
        return _classPrivateMethodGet(this, _set, _set2).call(this, {
          type: _constants.NUMERAL
        });
      }

      throw new Error("Converting a ".concat(this.type, " note to numeral is not supported"));
    }
  }, {
    key: "toNumeric",
    value: function toNumeric() {
      if (this.isNumeric()) {
        return this.clone();
      }

      if (this.isNumeral()) {
        return _classPrivateMethodGet(this, _set, _set2).call(this, {
          type: _constants.NUMERIC
        });
      }

      throw new Error("Converting a ".concat(this.type, " note to numeric is not supported"));
    }
  }, {
    key: "isMinor",
    value: function isMinor() {
      return this.minor;
    }
  }, {
    key: "equals",
    value: function equals(otherNote) {
      return this._note === otherNote._note && this.type === otherNote.type && this.minor === otherNote.minor;
    }
  }, {
    key: "clone",
    value: function clone() {
      return _classPrivateMethodGet(this, _set, _set2).call(this, {});
    }
  }, {
    key: "up",
    value: function up() {
      return this.change(1);
    }
  }, {
    key: "down",
    value: function down() {
      return this.change(-1);
    }
  }, {
    key: "isOneOf",
    value: function isOneOf() {
      for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
        options[_key] = arguments[_key];
      }

      return options.includes(this._note);
    }
  }, {
    key: "isNumeric",
    value: function isNumeric() {
      return this.is(_constants.NUMERIC);
    }
  }, {
    key: "isChordSymbol",
    value: function isChordSymbol() {
      return this.is(_constants.SYMBOL);
    }
  }, {
    key: "isNumeral",
    value: function isNumeral() {
      return this.is(_constants.NUMERAL);
    }
  }, {
    key: "is",
    value: function is(noteType) {
      return this.type === noteType;
    }
  }, {
    key: "getTransposeDistance",
    value: function getTransposeDistance(minorKey) {
      if (minorKey) {
        return TRANSPOSE_DISTANCE_MINOR[this._note];
      }

      return TRANSPOSE_DISTANCE_MAJOR[this._note];
    }
  }, {
    key: "change",
    value: function change(delta) {
      if (this.isChordSymbol()) {
        var charCode;
        charCode = keyToCharCode(this._note);
        charCode += delta;
        charCode = clamp(charCode, A, G);
        return _classPrivateMethodGet(this, _set, _set2).call(this, {
          note: String.fromCharCode(charCode)
        });
      }

      var newNote = clamp(this._note + delta, 1, 7);

      if (newNote < 1) {
        newNote += 7;
      } else if (newNote > 7) {
        newNote -= 7;
      }

      return _classPrivateMethodGet(this, _set, _set2).call(this, {
        note: newNote
      });
    }
  }, {
    key: "note",
    get: function get() {
      if (this.isNumeral()) {
        var numeral = numberToNumeral(this._note);

        if (this.isMinor()) {
          return numeral.toLowerCase();
        }

        return numeral;
      }

      return this._note;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.note);
    }
  }], [{
    key: "parse",
    value: function parse(note) {
      if (/^[A-Ga-g]$/.test(note)) {
        return new Note({
          note: note.toUpperCase(),
          type: _constants.SYMBOL
        });
      }

      if (/^[1-7]$/.test(note)) {
        return new Note({
          note: parseInt(note, 10),
          type: _constants.NUMERIC
        });
      }

      var romanNumeralValue = numeralToNumber(note);

      if (romanNumeralValue) {
        return new Note({
          note: romanNumeralValue,
          type: _constants.NUMERAL,
          minor: note.toLowerCase() === note
        });
      }

      throw new Error("Invalid note ".concat(note));
    }
  }]);

  return Note;
}();

function _set2(attributes) {
  return new this.constructor(_objectSpread({
    note: this._note,
    type: this.type,
    minor: this.minor
  }, attributes));
}

var _default = Note;
exports["default"] = _default;