"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _chord_lyrics_pair = _interopRequireDefault(require("./chord_lyrics_pair"));

var _tag = _interopRequireDefault(require("./tag"));

var _comment = _interopRequireDefault(require("./comment"));

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Represents a line in a chord sheet, consisting of items of type ChordLyricsPair or Tag
 */
var Line = /*#__PURE__*/function () {
  function Line() {
    _classCallCheck(this, Line);

    /**
     * The items ({@link ChordLyricsPair} or {@link Tag} or {@link Comment}) of which the line consists
     * @member
     * @type {Array.<(ChordLyricsPair|Tag|Comment)>}
     */
    this.items = [];
    /**
     * The line type, This is set by the ChordProParser when it read tags like {start_of_chorus} or {start_of_verse}
     * Values can be {@link VERSE}, {@link CHORUS} or {@link NONE}
     * @member
     * @type {string}
     */

    this.type = _constants.NONE;
    this.currentChordLyricsPair = null;
  }
  /**
   * Indicates whether the line contains any items
   * @returns {boolean}
   */


  _createClass(Line, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.items.length === 0;
    }
    /**
     * Adds an item ({@link ChordLyricsPair} or {@link Tag}) to the line
     * @param {ChordLyricsPair|Tag} item The item to be added
     */

  }, {
    key: "addItem",
    value: function addItem(item) {
      if (item instanceof _tag["default"]) {
        this.addTag(item);
      } else if (item instanceof _chord_lyrics_pair["default"]) {
        this.addChordLyricsPair(item);
      } else if (item instanceof _comment["default"]) {
        this.addComment(item);
      } else {
        this.items.push(item);
      }
    }
    /**
     * Indicates whether the line contains items that are renderable
     * @returns {boolean}
     */

  }, {
    key: "hasRenderableItems",
    value: function hasRenderableItems() {
      return this.items.some(function (item) {
        return item.isRenderable();
      });
    }
    /**
     * Returns a deep copy of the line and all of its items
     * @returns {Line}
     */

  }, {
    key: "clone",
    value: function clone() {
      return this.mapItems(null);
    }
  }, {
    key: "mapItems",
    value: function mapItems(func) {
      var clonedLine = new Line();
      clonedLine.items = this.items.map(function (item) {
        var clonedItem = item.clone();
        return func ? func(clonedItem) : clonedItem;
      }).filter(function (item) {
        return item;
      });
      clonedLine.type = this.type;
      return clonedLine;
    }
    /**
     * Indicates whether the line type is {@link VERSE}
     * @returns {boolean}
     */

  }, {
    key: "isVerse",
    value: function isVerse() {
      return this.type === _constants.VERSE;
    }
    /**
     * Indicates whether the line type is {@link CHORUS}
     * @returns {boolean}
     */

  }, {
    key: "isChorus",
    value: function isChorus() {
      return this.type === _constants.CHORUS;
    }
    /**
     * Indicates whether the line contains items that are renderable. Please use {@link hasRenderableItems}
     * @deprecated
     * @returns {boolean}
     */

  }, {
    key: "hasContent",
    value: function hasContent() {
      return this.hasRenderableItems();
    }
  }, {
    key: "addChordLyricsPair",
    value: function addChordLyricsPair(chords, lyrics) {
      if (chords instanceof _chord_lyrics_pair["default"]) {
        this.currentChordLyricsPair = chords;
      } else {
        this.currentChordLyricsPair = new _chord_lyrics_pair["default"](chords, lyrics);
      }

      this.items.push(this.currentChordLyricsPair);
      return this.currentChordLyricsPair;
    }
  }, {
    key: "ensureChordLyricsPair",
    value: function ensureChordLyricsPair() {
      if (!this.currentChordLyricsPair) {
        this.addChordLyricsPair();
      }
    }
  }, {
    key: "chords",
    value: function chords(chr) {
      this.ensureChordLyricsPair();
      this.currentChordLyricsPair.chords += chr;
    }
  }, {
    key: "lyrics",
    value: function lyrics(chr) {
      this.ensureChordLyricsPair();
      this.currentChordLyricsPair.lyrics += chr;
    }
  }, {
    key: "addTag",
    value: function addTag(name, value) {
      var tag = name instanceof _tag["default"] ? name : new _tag["default"](name, value);
      this.items.push(tag);
      return tag;
    }
  }, {
    key: "addComment",
    value: function addComment(content) {
      var comment = content instanceof _comment["default"] ? content : new _comment["default"](content);
      this.items.push(comment);
      return comment;
    }
  }, {
    key: "set",
    value: function set(properties) {
      return new this.constructor(_objectSpread({
        type: this.type,
        items: this.items
      }, properties));
    }
  }]);

  return Line;
}();

var _default = Line;
exports["default"] = _default;